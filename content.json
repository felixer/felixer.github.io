{"meta":{"title":"算法、数据、生活","subtitle":"学习总结 思考感悟","description":"学习总结 思考感悟","author":"Liu Lin","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2018-01-28T08:33:21.000Z","updated":"2018-01-28T08:33:44.000Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-01-28T08:29:11.000Z","updated":"2018-01-28T08:31:54.000Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-01-28T08:32:35.000Z","updated":"2018-01-28T08:32:51.000Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python安装 ","slug":"python安装","date":"2018-02-26T13:28:54.000Z","updated":"2018-02-26T13:31:33.000Z","comments":true,"path":"2018/02/26/python安装/","link":"","permalink":"http://yoursite.com/2018/02/26/python安装/","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"基础","slug":"python/基础","permalink":"http://yoursite.com/categories/python/基础/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"安装","slug":"安装","permalink":"http://yoursite.com/tags/安装/"}]},{"title":"python简介","slug":"python简介","date":"2018-02-26T13:24:50.000Z","updated":"2018-02-26T13:31:29.000Z","comments":true,"path":"2018/02/26/python简介/","link":"","permalink":"http://yoursite.com/2018/02/26/python简介/","excerpt":"","text":"","categories":[{"name":"python","slug":"python","permalink":"http://yoursite.com/categories/python/"},{"name":"基础","slug":"python/基础","permalink":"http://yoursite.com/categories/python/基础/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"},{"name":"简介","slug":"简介","permalink":"http://yoursite.com/tags/简介/"}]},{"title":"选择排序-泛型、性能测试","slug":"选择排序-泛型、性能测试","date":"2018-01-31T02:13:47.000Z","updated":"2018-01-31T02:37:33.000Z","comments":true,"path":"2018/01/31/选择排序-泛型、性能测试/","link":"","permalink":"http://yoursite.com/2018/01/31/选择排序-泛型、性能测试/","excerpt":"创建辅助函数用来自动生成测试数据和性能测试，通过验证选择排序的时间复杂度在O(n^2)，基本是数量的平方级别 数据量 花费时间 200 3ms 2000 14ms 20000 825ms 200000 104383ms","text":"创建辅助函数用来自动生成测试数据和性能测试，通过验证选择排序的时间复杂度在O(n^2)，基本是数量的平方级别 数据量 花费时间 200 3ms 2000 14ms 20000 825ms 200000 104383ms 泛型1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package felix.algo;import felix.util.SortTestHelper;/** * Created by lbb on 2018/1/31. */public class A2_SelectionSortT &#123;// 不允许产生实例 private A2_SelectionSortT() &#123;&#125;// 选择排序算法 public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(T[] arr) &#123;// 1. 选择排序 for(int i=0; i&lt;arr.length; i++) &#123;// 2. 定义最小索引值 int minIndex = i;// 3. 找到最小值 for(int j=i+1; j&lt;arr.length; j++) &#123; if (arr[j].compareTo(arr[minIndex]) &lt; 0) minIndex = j; &#125;// 4. 交换 swap(arr, i, minIndex); &#125; &#125; private static void swap(Object[] arr, int i, int minIndex) &#123; Object temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; public static void main(String[] args) &#123; int N = 100000; Integer[] arr = SortTestHelper.generateRandomIntegerArray(N,1,100); SortTestHelper.testSort(&quot;felix.algo.A2_SelectionSortT&quot;,arr); &#125;&#125; 辅助函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869package felix.util;import java.lang.reflect.Method;public class SortTestHelper &#123;// SortTestHelper不允许产生任何实例 private SortTestHelper() &#123;&#125;// 生成有n个元素的随机数组，每个元素的随机范围为[rangeL,rangeR] public static Integer[] generateRandomIntegerArray(int n,int rangeL,int rangeR) &#123;// 1. 条件判断 assert rangeL &lt;= rangeL;// 2. 定义返回数组 Integer[] arr = new Integer[n];// 3. 生成数组 for(int i=0; i&lt;n; i++) &#123; arr[i] = new Integer((int)(Math.random()*(rangeR - rangeL + 1) + rangeL)); &#125;// 4. 返回随机数组 return arr; &#125;// 输出arr数组的所有内容 public static void printArr(Object[] arr) &#123; for (int i=0; i&lt;arr.length; i++) &#123; System.out.print(arr[i]); System.out.print(&apos; &apos;); &#125; System.out.println(); &#125; public static boolean isSorted(Comparable[] arr) &#123; for(int i=0; i&lt;arr.length - 1; i++) &#123; if(arr[i].compareTo(arr[i+1]) &gt; 0) return false; &#125; return true; &#125; public static void testSort(String sortClassName, Comparable[] arr) &#123; try&#123; // 通过sortClassName获得排序函数的Class对象 Class sortClass = Class.forName(sortClassName); // 通过排序函数的Class对象获得排序方法 Method sortMethod = sortClass.getMethod(&quot;sort&quot;,new Class[]&#123;Comparable[].class&#125;); // 排序参数只有一个，是可比较数组arr Object[] params = new Object[]&#123;arr&#125;; long startTime = System.currentTimeMillis(); // 调用排序函数 sortMethod.invoke(null,params); long endTime = System.currentTimeMillis(); assert isSorted( arr ); System.out.println( sortClass.getSimpleName()+ &quot; : &quot; + (endTime-startTime) + &quot;ms&quot; ); &#125; catch(Exception e)&#123; e.printStackTrace(); &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"基础","slug":"算法/基础","permalink":"http://yoursite.com/categories/算法/基础/"},{"name":"排序","slug":"算法/基础/排序","permalink":"http://yoursite.com/categories/算法/基础/排序/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"性能测试","slug":"性能测试","permalink":"http://yoursite.com/tags/性能测试/"},{"name":"选择排序","slug":"选择排序","permalink":"http://yoursite.com/tags/选择排序/"}]},{"title":"选择排序","slug":"算法的重要性","date":"2018-01-30T10:56:32.000Z","updated":"2018-01-31T02:17:49.000Z","comments":true,"path":"2018/01/30/算法的重要性/","link":"","permalink":"http://yoursite.com/2018/01/30/算法的重要性/","excerpt":"选择排序 算法无处不在，工作、生活（百度、Google、人工智能、推荐算法）、游戏、性能优化，无处不在 学好算法，才能创造出更多有意义的东西,做一个真正的科学家，而不是仅仅码农。 什么时候开始都不晚，😑！ 线性 树形 图论 选择排序的时间复杂度为O(n^2),排序类的最小复杂度时间为O(nlogn)： 基础 比较基础，容易实现，是一些简单场景的首选； 在一些特殊情况下简单算法更加的有效； 通过简单算法进而衍生出复杂算法是有效的思维方式，作为子过程进行复用； 选择排序：对待排序数据进行遍历，从带遍历中选出一个最小的一个元素，将其放到第一的位置，重复执行，直到最后一个元素为止。","text":"选择排序 算法无处不在，工作、生活（百度、Google、人工智能、推荐算法）、游戏、性能优化，无处不在 学好算法，才能创造出更多有意义的东西,做一个真正的科学家，而不是仅仅码农。 什么时候开始都不晚，😑！ 线性 树形 图论 选择排序的时间复杂度为O(n^2),排序类的最小复杂度时间为O(nlogn)： 基础 比较基础，容易实现，是一些简单场景的首选； 在一些特殊情况下简单算法更加的有效； 通过简单算法进而衍生出复杂算法是有效的思维方式，作为子过程进行复用； 选择排序：对待排序数据进行遍历，从带遍历中选出一个最小的一个元素，将其放到第一的位置，重复执行，直到最后一个元素为止。 12345678910111213141516171819202122232425262728293031public class SelectionSort &#123; public static void sort(int[] arr) &#123; int n = arr.length; for(int i=0; i &lt; n; i++) &#123; int minIndex = i; for(int j= i + 1; j&lt;n ; j++) &#123; if(arr[j]&lt;arr[minIndex]) minIndex = j; &#125; swap(arr,i, minIndex); &#125; &#125; private static void swap(int[] arr,int i,int minIndex) &#123; int t = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = t; &#125; public static void main(String[] args) &#123; int[] arr = &#123;10,9,8,7,6,5,4,3,2,1&#125;; SelectionSort.sort(arr); for( int i = 0 ; i &lt; arr.length ; i ++ )&#123; System.out.print(arr[i]); System.out.print(' '); &#125; System.out.println(); &#125;&#125;输出&gt;1 2 3 4 5 6 7 8 9 10","categories":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/categories/算法/"},{"name":"基础","slug":"算法/基础","permalink":"http://yoursite.com/categories/算法/基础/"},{"name":"排序","slug":"算法/基础/排序","permalink":"http://yoursite.com/categories/算法/基础/排序/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"纪念第一篇博客","slug":"纪念第一篇博客","date":"2018-01-28T13:13:58.000Z","updated":"2018-01-30T10:57:13.000Z","comments":true,"path":"2018/01/28/纪念第一篇博客/","link":"","permalink":"http://yoursite.com/2018/01/28/纪念第一篇博客/","excerpt":"","text":"前言 一路走来，经历了很多，充满了矛盾，总是自命不凡却又蹉跎岁月。不过我仍然坚信自己与众不同，也许没有别人聪明，也许没有别人努力，一直以来我觉得自己最有优势的就是能够发现问题的本质。这是我第一篇博客，主要用来记录自己生活、学习、工作的点点滴滴，是对自己的一种反思和检查。希望你越来越好，成为你当初心中的那个自己。 未来的路学习准备开始学习大数据相关的技术，列了一个计划： 明天开始第一天，Fighting！","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"},{"name":"感悟","slug":"生活/感悟","permalink":"http://yoursite.com/categories/生活/感悟/"}],"tags":[]}]}